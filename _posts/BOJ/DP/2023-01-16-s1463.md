---
title: "🤍III [1463/C++] 1로 만들기"

categories:
  - DP

tags:
  - BOJ
  - DP
  - silver

toc: true
toc_sticky: true
toc_label: "1463"
toc_icon: "dice-three"
last_modified_at: 2023-01-16

use_math: true
---

<br>

---

# 1. [문제](https://www.acmicpc.net/problem/1463)

<br>

<img src="https://user-images.githubusercontent.com/93882395/212811216-5d5d812a-eca4-4ea2-ad48-1198f813ab39.png" alt="image" style="zoom: 67%;" /> 



다이나믹 프로그래밍의 기본이 되는 문제다. 바텀업 방식으로 문제를 해결할 수 있다.

<br>

# 2. 코드

<script src="https://gist.github.com/yj59/8aa142bc27c0037758e93f8a492b702d.js"></script>

<img src="C:\Users\lucet\AppData\Roaming\Typora\typora-user-images\image-20230117192136690.png" alt="image-20230117192136690" style="zoom:50%;" /> 

<br>

---

# 3. 정리

다이나믹 프로그래밍 이론을 공부하기 전, 세 수의 연산 결과를 예측해 경우의 수로 나누어 코드를 작성했다. 

예를 들어 `n`이 2로 나누어 떨어지지만 4로 나누어 떨어지지 않으면서 `(n-1)`이 3으로 나누어 떨어지면 1을 먼저 빼고 다음 반복문에서 `n%3==0` 조건문에 걸리게 하기 같은 ...ㅎㅎ 경우의 수가 너무 많아질 뿐더러 내가 세운 조건문이 모든 `n`에 대하여 이득이라는 보장이 없다. 케이스가 제시된 입력마다 유동적으로 바뀔 경우에는 모든 경우를 전부 확인하는 방법을 사용해보자. 앞으로 명확히 증명할 수 없는 가정으로는 알고리즘 세우기 말기! 더 고민해보면 확실한 답안이 나올 거다.

아직 실버 몇 문제만 풀어보았지만, 쉬운 문제는 규칙을 찾아 계산 결과를 차례대로 배열에 넣으면 얼추 풀리는 듯하다. 규칙 찾기가 감이 잘 안 온다. 문제를 많이 풀어보고 점화식 세우는 감을 좀 잡아야 하겠다. 이번주에 DP 이론 잡아보자🤓
