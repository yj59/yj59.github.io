# 2. #define

> 항목 2: `#define`을 쓰려거든 `const, enum, inline`을 떠올리자

<br>

**define 코드 예제**

```c++
#define ASPECT_RATIO 1.653
```

소스 코드가 컴파일러로 넘어가기 전에 선행 처리자가 해당 코드를 숫자 상수로 변환시킨다. 결과적으로, `ASPECT_RATIO`라는 이름은 컴팡리러가 쓰는 기호 테이블에 들어가지 않는다!

숫자 상수로 대체된 코드에서 컴파일 에러가 발생하면 곤란한 상황이 발생한다,

* 소스 코드엔 `ASPECT_RATIO`가 있었는데 에러 메시지엔 `1.653`가 출력됨
  * 만약, 해당 `define`이 정의된 코드가 직접 작성한 것이 아니라면 어느 코드인지 찾는 데 시간을 낭비하게 됨
  * 기호식 디버거에도 같은 문제가 발생할 수 있음(기호 테이블에 들어가지 않기 때문)

<br>

위 예제 코드의 해결안

```c++
const double AspectRatio = 1.653
// 대문자로만 표기하는 이름은 대개 매크로에 쓰는 것이므로, 이름 표기도 바꿔주어야 한다!
```

* 언어 차원에서 지원하는 상수 타입의 데이터이므로 컴파일러도 인식 가능
  * 컴파일러 기호 테이블에 저장
  * 상수가 부동소수점 실수 타입일 경우, 컴파일을 거친 최종 코드의 크기가 `#define`보다 작게 나올 수 있음
    * `#define`의 경우 `1.653`의 사본이 등장 횟수마다 만들어지지만, 상수 타입일 경우 딱 한 개만 생성

<br>

## **`#define` => 상수 교체 시 주의사항**



### 1. 상수 포인터 정의

* 상수 포인터(`constant pointer`) 정의

  * 대개 헤더 파일에서 상수를 정의하므로, 포인터를 반드시 `const`로 선언

  * 포인터가 가리키는 대상도 함께 `const`로 선언하는 것이 일반적임

    *eg) 어떤 헤더 파일 안에 `char*` 기반의 문자열 상수를 정의할 경우, `const`를 두 번 기재*

    `const char * const authorName = "Scott Meyers";`

    `const std::string authorName("Scott Meyers");` => **`string`객체 사용을 권장!**

<br>

### **2. 클래스 멤버로 상수 정의**

어떤 상수의 유효범위를 클래스로 한정할 경우, 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적 멤버로 선언하자.



```c++
class GamePlayer{
private:
	static const int NumTurns = 5;	// 상수 선언
    int scores[NumTurns];			// 상수를 사용하는 부분
	...
};
```

* 코드 작성 시 선언 후 정의부를 작성하는 것이 일반적임

* 정적 멤버로 만들어지는 정수류 타입의 클래스 상수는 정의 마련하지 않음

  * 클래스 상수의 주소를 구할 경우에만 정의부 구현

    `const int GamePlayer::NumTurns;`

    * 별도의 정의를 기재할 경우, 값을 제공하지 않음
      * 이때, 클래스 상수의 정의는 구현 파일에 기재
      * 클래스 상수의 초기값은 해당 상수가 선언된 시점에 바로 초기화

<br>

**상수 대체 시 주의사항**

* 클래스 상수는 `#define`으로 만들지 말자

  * `#define`은 클래스 상수를 정의하는데 사용할 수 x

  * 어떤 형태의 캡슐화 혜택도 받을 수 없음

    *eg) `private` 형태의 `#define` 구문은 존재하지 않음*

<br>

---

<br>

## 클래스 멤버 초기화가 어려운 경우

컴파일러가 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 맞지 않는다고 판단할 경우, 초기값은 상수 정의 시점에 기재하자.

```c++
class CostEstimate {
private:
    static const double FudgeFactor;
    ...
};

// 정적 클래스 상수의 정의 => 구현 파일에 적자!
const double CostEstimate::FudgeFactor = 1.35;
```

* 이때, 해당 클래스를 컴파일하는 도중 클래스 상수의 값이 필요한 경우가 생김

  * `GamePlayer::scores`과 같이 배열 멤버 선언

    => **"나열자 둔갑술(`enmu hack`)"** 기법을 사용해 해결 가능

<br>

```c++
class GamePlayer {
private:
    // "나열자 둔갑술": NumTurns를 5에 대한 기호식 이름으로 만든다.
    enum { NumTurns = 5 };	
    
    int scores[NumTurns];
    ...
};
```

