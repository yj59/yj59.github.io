---
title: "[RasterTek/DirectX11] #2 í”„ë ˆì„ì›Œí¬ ë° ì°½ ë§Œë“¤ê¸°"

date: 2025-01-30 00:00:00 +0900
author: yejin

categories: [DirectX 11, Tutorials]
tags: [RasterTek, tuto]

mermaid: true
---

> **ğŸ“– ì°¸ê³ ìë£Œ**
>
> * [RasterTek - DirectX 11 on Windows 10 Tutorials](https://rastertek.com/tutdx11win10.html)
>
> <br>
> 
> **ğŸ–¥ï¸ ê°œë°œí™˜ê²½**
> 
> *   Window 11
> *   Visual Studio 2022
>

<br>

DirectX11ë¡œ ì½”ë”©ì„ ì‹œì‘í•˜ê¸° ì „ì— ê°„ë‹¨í•œ í”„ë ˆì„ì›Œí¬ë¥¼ êµ¬ì¶•í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

í•´ë‹¹ í”„ë ˆì„ì›Œí¬ëŠ” ê¸°ë³¸ì ì¸ Windows ê¸°ëŠ¥ì„ ì²˜ë¦¬í•˜ê³ , DX11ì„ í•™ìŠµí•˜ê¸° ìœ„í•´ ì½”ë“œë¥¼ ì²´ê³„ì ì´ê³  ì½ê¸° ì‰½ê²Œ í™•ì¥í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤€ë‹¤.

*rastertek íŠœí† ë¦¬ì–¼ì€ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ì‹œë„í•´ ë³´ëŠ” ê²ƒì´ë¯€ë¡œ, í”„ë ˆì„ì›Œí¬ë¥¼ ê°€ë³ê²Œ ìœ ì§€í•˜ê³  ìì²´ ë Œë”ë§ ì—”ì§„ì„ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤.*

<br>

## í”„ë ˆì„ì›Œí¬

í”„ë ˆì„ì›Œí¬ëŠ” 4ê°€ì§€ í•­ëª©ìœ¼ë¡œ ì‹œì‘í•œë‹¤.


```mermaid
---
title: Framework
config:
  look: handDrawn
  theme: neutral
---
graph TD
	WinMain --- SystemClass
	SystemClass --- InputClass
	SystemClass --- ApplicationClass

```

* `WinMain`: ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì§„ì…ì  ì²˜ë¦¬
  * `SystemClass`: WinMain í•¨ìˆ˜ ë‚´ì—ì„œ í˜¸ì¶œë˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ë¥¼ ìº¡ìŠí™”
    * `InputClass`: ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬
    * `ApplicationClass`: DirectX ê·¸ë˜í”½ ì½”ë“œ ì²˜ë¦¬

<br>

## WinMain

<br>

```c++
// Filename: main.cpp

#include "systemclass.h"


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pScmdline, int iCmdshow)
{
	SystemClass* System;
	bool result;
	
	
	// Create the system object.
	System = new SystemClass;

	// Initialize and run the system object.
	result = System->Initialize();
	if(result)
	{
		System->Run();
	}

	// Shutdown and release the system object.
	System->Shutdown();
	delete System;
	System = 0;

	return 0;
}
```

WinMain í•¨ìˆ˜ì—ì„œ SystemClassë¥¼ ìƒì„±í•œ í›„ ì´ˆê¸°í™”í•œë‹¤.

ì´ˆê¸°í™”ì— ë¬¸ì œê°€ ì—†ìœ¼ë©´ SystemClassì˜ `Run`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.

`Run` í•¨ìˆ˜ëŠ” ìì²´ì ìœ¼ë¡œ ë°˜ë³µë¬¸ì„ ì‹¤í–‰í•˜ê³  ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ë™ì‘í•œë‹¤. `Run` í•¨ìˆ˜ê°€ ì™„ë£Œëœ í›„ System objectë¥¼ ì¢…ë£Œí•œë‹¤. 

ì „ì²´ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ SystemClass ë‚´ë¶€ì— ìº¡ìŠí™”í•´ ê°„ë‹¨í•˜ê²Œ ìœ ì§€í•œë‹¤.



<br>

## SystemClass.h

<br>

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: systemclass.h
////////////////////////////////////////////////////////////////////////////////

#ifndef _SYSTEMCLASS_H_
#define _SYSTEMCLASS_H_
```

```c++
///////////////////////////////
// PRE-PROCESSING DIRECTIVES //
///////////////////////////////
#define WIN32_LEAN_AND_MEAN
```



`WIN32_LEAN_AND_MEAN`ì„ ì •ì˜í•œë‹¤.

* ë¹Œë“œ í”„ë¡œì„¸ìŠ¤ë¥¼ ê°€ì†í™”í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¼ë¶€ Win32 API ì œì™¸

  => Win32 í—¤ë” íŒŒì¼ì˜ í¬ê¸° ì¤„ì„



<br>

```c++
//////////////
// INCLUDES //
//////////////
#include <windows.h>

///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "inputclass.h"
#include "applicationclass.h"
```

`windows.h`ë¥¼ í¬í•¨í•´  ìœˆë„ìš°ì˜ ìƒì„±ì/ì†Œë©¸ì í•¨ìˆ˜ì™€ ê¸°íƒ€ win32 í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ í•œë‹¤. í”„ë ˆì„ì›Œí¬ì˜ ë‘ í´ë˜ìŠ¤ë¥¼ includeí•´ ì‹œìŠ¤í…œ í´ë˜ìŠ¤ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

<br>

```c++
////////////////////////////////////////////////////////////////////////////////
// Class name: SystemClass
////////////////////////////////////////////////////////////////////////////////
class SystemClass
{
public:
	SystemClass();
	SystemClass(const SystemClass&);
	~SystemClass();

	bool Initialize();
	void Shutdown();
	void Run();

	LRESULT CALLBACK MessageHandler(HWND, UINT, WPARAM, LPARAM);

private:
	bool Frame();
	void InitializeWindows(int&, int&);
	void ShutdownWindows();

private:
	LPCWSTR m_applicationName;
	HINSTANCE m_hinstance;
	HWND m_hwnd;

	InputClass* m_Input;
	ApplicationClass* m_Application;
};
```

í´ë˜ìŠ¤ ì •ì˜

* `WinMain`ì—ì„œ í˜¸ì¶œëœ `Initialize`, `Shotdown`, `Run` í•¨ìˆ˜
* í•´ë‹¹ í•¨ìˆ˜ì—ì„œ í˜¸ì¶œë  private í•¨ìˆ˜
* `MessageHandler`
  * ì‹œìŠ¤í…œì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì „ì†¡ë  Windows System message ì²˜ë¦¬
* `m_Input`, `m_Application`
  * ì…ë ¥ê³¼ ê·¸ë˜í”½ ë Œë”ë§ì„ ì²˜ë¦¬í•  ë‘ ê°ì²´ì— ëŒ€í•œ í¬ì¸í„°

<br>

```c++
/////////////////////////
// FUNCTION PROTOTYPES //
/////////////////////////
static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

/////////////
// GLOBALS //
/////////////
static SystemClass* ApplicationHandle = 0;

#endif
```

`wndProc`, `ApplicationHandle`

=> ìœˆë„ìš° ì‹œìŠ¤í…œ ë©”ì‹œì§€ë¥¼ SystemClassì˜ MessageHandler í•¨ìˆ˜ë¡œ ë¦¬ë””ë ‰ì…˜í•  ìˆ˜ ìˆë‹¤.

<br>



## Systemclass.cpp

### ìƒì„±ì

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: systemclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "systemclass.h"
```

```c++
SystemClass::SystemClass()
{
    m_Input = 0;
    m_Application = 0;
}
```

í´ë˜ìŠ¤ ìƒì„±ìì—ì„œ ê°ì²´ í¬ì¸í„°ë¥¼ nullë¡œ ì´ˆê¸°í™”í•œë‹¤.

ê°ì²´ ì´ˆê¸°í™”ê°€ ì‹¤íŒ¨í•œ ê²½ìš° `Shotdown` í•¨ìˆ˜ê°€ í•´ë‹¹ ê°ì²´ë¥¼ ì •ë¦¬ë¥¼ ì‹œë„í•œë‹¤. ë§Œì•½, ê°ì²´ê°€ nullì´ ì•„ë‹ˆë¼ë©´ ìœ íš¨í•œ ê°ì²´ë¼ê³  íŒë‹¨í•˜ê³  ì •ë¦¬í•œë‹¤.

ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ëª¨ë“  í¬ì¸í„°ì™€ ë³€ìˆ˜ë¥¼ nullë¡œ ì´ˆê¸°í™”í•˜ëŠ” ìŠµê´€ì„ ë“¤ì´ëŠ” ê²ƒì´ ì¢‹ë‹¤. ë¹Œë“œ ì‹œ ì‹¤íŒ¨í•  ìˆ˜ë„ ìˆê¸° ë•Œë¬¸!



<br>

### ë³µì‚¬ìƒì„±ì&ì†Œë©¸ì

```c++
SystemClass::SystemClass(const SystemClass& other)
{
}

SystemClass::~SystemClass()
{
}

```

ë³µì‚¬ ìƒì„±ìì™€ ì†Œë©¸ìê°€ ê³µë€ì¼ ê²½ìš° ì»´íŒŒì¼ëŸ¬ê°€ ì„ì˜ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ë¹ˆ ë³µì‚¬ ìƒì„±ìì™€ ì†Œë©¸ìë¥¼ ë§Œë“¤ì–´ ë†“ëŠ”ë‹¤.

<br>

### Initialize

```c++
bool SystemClass::Initialize()
{
    int screenWidth, screenHeight;
    bool result;

    // í™”ë©´ ë„ˆë¹„ì™€ ë†’ì´ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•œ í›„ InitializeWindowsì— ë³€ìˆ˜ ì „ë‹¬
    screenWidth = 0;
    screenHeight = 0;

    // Initialize the windows api.
    InitializeWindows(screenWidth, screenHeight);

    // ì…ë ¥ ê°ì²´ ìƒì„± í›„ ì´ˆê¸°í™”
    // ì‚¬ìš©ìì˜ í‚¤ë³´ë“œ ì…ë ¥ì„ ì½ëŠ”ë° ì‚¬ìš©ë¨
    m_Input = new InputClass;
    m_Input->Initialize();

    // ì• í”Œë¦¬ì¼€ì´ì…˜ ê°ì²´ ìƒì„± í›„ ì´ˆê¸°í™”
    // ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ê·¸ë˜í”½ì„ ë Œë”ë§í•˜ëŠ” ë° ì‚¬ìš©
    m_Application = new ApplicationClass;

    result = m_Application->Initialize(screenWidth, screenHeight, m_hwnd);
    if(!result)
    {
        return false;
    }

    return true;
}
```

`bool SystemClass::Initialize()`: ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •ì„ ìˆ˜í–‰

* `InitializeWindows`ë¥¼ í˜¸ì¶œí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©í•  ì°½ ìƒì„±
* ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©ì ì…ë ¥ì„ ì²˜ë¦¬
* í™”ë©´ì— ê·¸ë˜í”½ì„ ë Œë”ë§í•˜ëŠ”ë° ì‚¬ìš©í•  ì…ë ¥/ì• í”Œë¦¬ì¼€ì´ì…˜ ê°ì²´ë¥¼ ìƒì„± í›„ ì´ˆê¸°í™”



<br>

### Shutdown 

```c++
void SystemClass::Shutdown()
{
	// Release the application class object.
	if(m_Application)
	{
		m_Application->Shutdown();
		delete m_Application;
		m_Application = 0;
	}

	// Release the input object.
	if(m_Input)
	{
		delete m_Input;
		m_Input = 0;
	}

	// Shutdown the window.
	ShutdownWindows();
	
	return;
}
```

`void SystemClass::Shutdown()`: ì—°ê´€ ë™ì‘ ì •ë¦¬

* ì• í”Œë¦¬ì¼€ì´ì…˜ ë° ì…ë ¥ ê°ì²´ì™€ ê´€ë ¨ëœ ëª¨ë“  ê²ƒì„ ì¢…ë£Œ ë° í•´ì œ
* ìœˆë„ìš°ë¥¼ ì¢…ë£Œí•˜ê³  ê´€ë ¨ í•¸ë“¤ ì •ë¦¬

<br>

### Run

```c++
void SystemClass::Run()
{
	MSG msg;
	bool done, result;


	// Initialize the message structure.
	ZeroMemory(&msg, sizeof(MSG));
	
	// Loop until there is a quit message from the window or the user.
	done = false;
	while(!done)
	{
		// Handle the windows messages.
		if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		// If windows signals to end the application then exit out.
		if(msg.message == WM_QUIT)
		{
			done = true;
		}
		else
		{
			// Otherwise do the frame processing.
			result = Frame();
			if(!result)
			{
				done = true;
			}
		}

	}

	return;
}
```

`void SystemClass::Run()`

* ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì¢…ë£Œí•˜ê¸° ì „ê¹Œì§€ ëª¨ë“  ë™ì‘ ì²˜ë¦¬

* ì• í”Œë¦¬ì¼€ì´ì…˜ ì²˜ë¦¬: ê° loopë§ˆë‹¤ í˜¸ì¶œë˜ëŠ” Frame í•¨ìˆ˜ì—ì„œ ìˆ˜í–‰

  => ì• í”Œë¦¬ì¼€ì´ì…˜ êµ¬í˜„ ì‹œ ì—¼ë‘ì— ë‘ì!

  ```
  // pseudo code
  
  While ì¢…ë£Œ ì „
  	ìœˆë„ìš° ì‹œìŠ¤í…œ ë©”ì‹œì§€ í™•ì¸
  	ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì²˜ë¦¬
  	ì• í”Œë¦¬ì¼€ì´ì…˜ ë£¨í”„ ì²˜ë¦¬
  	í”„ë ˆì„ ì‘ì—…ë§ˆë‹¤, ì‚¬ìš©ìê°€ ì¢…ë£Œë¥¼ ì›í•˜ëŠ”ì§€ í™•ì¸
  ```



<br>



### Frame

```c++
bool SystemClass::Frame()
{
	bool result;


	// Check if the user pressed escape and wants to exit the application.
	if(m_Input->IsKeyDown(VK_ESCAPE))
	{
		return false;
	}

	// Do the frame processing for the application class object.
	result = m_Application->Frame();
	if(!result)
	{
		return false;
	}

	return true;
}
```

`void SystemClass::Frame()`

* ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ë™ì‘ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
* input objectë¥¼ í™•ì¸í•´ ì‚¬ìš©ìê°€ `Esc`í‚¤ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•˜ë ¤ëŠ”ì§€ í™•ì¸
* ì¢…ë£Œë¥¼ ì›í•˜ì§€ ì•Šìœ¼ë©´ ApplicationClass ê°ì²´ë¥¼ í˜¸ì¶œí•´ í”„ë ˆì„ ì²˜ë¦¬ ìˆ˜í–‰
  * ì´ ê³¼ì •ì—ì„œ í•´ë‹¹ í”„ë ˆì„ì˜ ê·¸ë˜í”½ ë Œë”ë§ ìˆ˜í–‰



<br>

### MessageHandler

```c++
LRESULT CALLBACK SystemClass::MessageHandler(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam)
{
	switch(umsg)
	{
		// Check if a key has been pressed on the keyboard.
		case WM_KEYDOWN:
		{
			// If a key is pressed send it to the input object so it can record that state.
			m_Input->KeyDown((unsigned int)wparam);
			return 0;
		}

		// Check if a key has been released on the keyboard.
		case WM_KEYUP:
		{
			// If a key is released then send it to the input object so it can unset the state for that key.
			m_Input->KeyUp((unsigned int)wparam);
			return 0;
		}

		// Any other messages send to the default message handler as our application won't make use of them.
		default:
		{
			return DefWindowProc(hwnd, umsg, wparam, lparam);
		}
	}
}
```

`LRESULT CALLBACK SystemClass::MessageHandler(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam)`

*   Windowsì˜ ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì²˜ë¦¬

    *   ê´€ì‹¬ìˆëŠ” íŠ¹ì • ì •ë³´ë¥¼ ë“¤ì„ ìˆ˜ ìˆìŒ

        *ì˜ˆì œ) í‚¤ê°€ ëˆŒë ¸ëŠ”ì§€ í•´ì œë˜ì—ˆëŠ”ì§€ë¥¼ ì½ê³ , Input ê°ì²´ì— ì „ë‹¬*

    *   íŠ¹ì • ì •ë³´ ì´ì™¸ì˜ ëª¨ë“  ì •ë³´ë“¤ì€ Windows ê¸°ë³¸ ë©”ì‹œì§€ ì²˜ë¦¬ê¸°ë¡œ ë‹¤ì‹œ ì „ë‹¬

<br>

### InitializeWindows

```c++
void SystemClass::InitializeWindows(int& screenWidth, int& screenHeight)
{
	WNDCLASSEX wc;
	DEVMODE dmScreenSettings;
	int posX, posY;


	// Get an external pointer to this object.	
	ApplicationHandle = this;

	// Get the instance of this application.
	m_hinstance = GetModuleHandle(NULL);

	// Give the application a name.
	m_applicationName = L"Engine";

	// Setup the windows class with default settings.
	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wc.lpfnWndProc   = WndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = m_hinstance;
	wc.hIcon         = LoadIcon(NULL, IDI_WINLOGO);
	wc.hIconSm       = wc.hIcon;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = m_applicationName;
	wc.cbSize        = sizeof(WNDCLASSEX);
	
	// Register the window class.
	RegisterClassEx(&wc);

	// Determine the resolution of the clients desktop screen.
	screenWidth  = GetSystemMetrics(SM_CXSCREEN);
	screenHeight = GetSystemMetrics(SM_CYSCREEN);

	// Setup the screen settings depending on whether it is running in full screen or in windowed mode.
	if(FULL_SCREEN)
	{
		// If full screen set the screen to maximum size of the users desktop and 32bit.
		memset(&dmScreenSettings, 0, sizeof(dmScreenSettings));
		dmScreenSettings.dmSize       = sizeof(dmScreenSettings);
		dmScreenSettings.dmPelsWidth  = (unsigned long)screenWidth;
		dmScreenSettings.dmPelsHeight = (unsigned long)screenHeight;
		dmScreenSettings.dmBitsPerPel = 32;			
		dmScreenSettings.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

		// Change the display settings to full screen.
		ChangeDisplaySettings(&dmScreenSettings, CDS_FULLSCREEN);

		// Set the position of the window to the top left corner.
		posX = posY = 0;
	}
	else
	{
		// If windowed then set it to 800x600 resolution.
		screenWidth  = 800;
		screenHeight = 600;

		// Place the window in the middle of the screen.
		posX = (GetSystemMetrics(SM_CXSCREEN) - screenWidth)  / 2;
		posY = (GetSystemMetrics(SM_CYSCREEN) - screenHeight) / 2;
	}

	// Create the window with the screen settings and get the handle to it.
	m_hwnd = CreateWindowEx(WS_EX_APPWINDOW, m_applicationName, m_applicationName, 
				WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_POPUP,
				posX, posY, screenWidth, screenHeight, NULL, NULL, m_hinstance, NULL);

	// Bring the window up on the screen and set it as main focus.
	ShowWindow(m_hwnd, SW_SHOW);
	SetForegroundWindow(m_hwnd);
	SetFocus(m_hwnd);

	// Hide the mouse cursor.
	ShowCursor(false);

	return;
}
```

`void SystemClass::InitializeWindows(int& screenWidth, int& screenHeight)`

*   ê°œë°œìëŠ” í•´ë‹¹ í•¨ìˆ˜ì— ë Œë”ë§ì— ì‚¬ìš©í•  ì°½ì„ ìƒì„±í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±
*   `InitializeWindows`ë¥¼ í˜¸ì¶œí•œ í•¨ìˆ˜ì— `screenWidth`ì™€ `screenHeight`ë¥¼ ë°˜í™˜
    *   ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ë°˜ì— í™œìš©í•  ìˆ˜ ìˆë„ë¡ í•¨
    *   ê¸°ë³¸ ì„¤ì • ì‹œ í…Œë‘ë¦¬ê°€ ì—†ëŠ” ê²€ì€ìƒ‰ ìœˆë„ìš°ë¡œ ì´ˆê¸°í™”
    *   ì „ì—­ë³€ìˆ˜ `FULL_SCREEN`ì— ë”°ë¼ ì°½, ì „ì²´ í™”ë©´ìœ¼ë¡œ ì¡°ì ˆ
        *   `true`: ì „ì²´ í™”ë©´ ìœˆë„ìš°
        *   `false`: 800x600 í¬ê¸°ì˜ ìœˆë„ìš°
    *   `applicationclass.h` íŒŒì¼ ë§¨ ìœ„ì— ì¶”ê°€í•´ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ í•¨
        *   *ì™œ  í•´ë‹¹ íŒŒì¼ì˜ í—¤ë” ëŒ€ì‹  ì „ì—­ ë³€ìˆ˜ë¥¼ ì¶”ê°€í–ˆëŠ”ì§€ ìƒê°í•´ë³´ì!*
            1.   ë³€ìˆ˜ì˜ ì—­í•  ë¶„ë¦¬? SystemClassëŠ” ì‹œìŠ¤í…œ ì „ë°˜ì„ ë‹¤ë£¨ëŠ” ë°˜ë©´, ApplicationClassëŠ” ê·¸ë˜í”½ ê´€ë ¨ì„ ë‹¤ë£¨ê¸° ë•Œë¬¸(ì„¤ì •ì„ ë³€ê²½í•˜ê¸°ë„ ìš©ì´)
            2.   SystemClassì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©´, SystemClassì˜ ë‹¤ë¥¸ ê¸°ëŠ¥ì´ í•„ìš”í•˜ì§€ ì•Šì€ íŒŒì¼ë“¤ë„ í—¤ë”ì— í¬í•¨í•´ì•¼ í•¨. ê·¸ë˜í”½ì´ í•„ìš”í•œ í—¤ë”ë§Œ ë¶ˆëŸ¬ì˜¤ë„ë¡ í•˜ì.

<br>

### ShutdownWindows

```c++
void SystemClass::ShutdownWindows()
{
	// Show the mouse cursor.
	ShowCursor(true);

	// Fix the display settings if leaving full screen mode.
	if(FULL_SCREEN)
	{
		ChangeDisplaySettings(NULL, 0);
	}

	// Remove the window.
	DestroyWindow(m_hwnd);
	m_hwnd = NULL;

	// Remove the application instance.
	UnregisterClass(m_applicationName, m_hinstance);
	m_hinstance = NULL;

	// Release the pointer to this class.
	ApplicationHandle = NULL;

	return;
}
```

`void SystemClass::ShutdownWindows()`

*   í™”ë©´ ì„¤ì •ì„ ì›ë˜ëŒ€ë¡œ ë³µì›
*   ìœˆë„ìš°ì™€ ê´€ë ¨ëœ í•¸ë“¤ í•´ì œ



<br>

### WndProc



```c++
LRESULT CALLBACK WndProc(HWND hwnd, UINT umessage, WPARAM wparam, LPARAM lparam)
{
	switch(umessage)
	{
		// ìœˆë„ìš°ê°€ Destroyë˜ì—ˆëŠ”ì§€ í™•ì¸
		case WM_DESTROY:
		{
			PostQuitMessage(0);	// ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ ìš”ì²­
			return 0;
		}

		// ì°½ì´ ë‹«í˜”ëŠ”ì§€ í™•ì¸
		case WM_CLOSE:
		{
			PostQuitMessage(0);		
			return 0;
		}

		// ê·¸ ì™¸ ëª¨ë“  ë©”ì‹œì§€ëŠ” SystemClassì˜ MessageHandlerë¡œ ì „ë‹¬
		default:
		{
			return ApplicationHandle->MessageHandler(hwnd, umessage, wparam, lparam);
		}
	}
}
```



`LRESULT CALLBACK WndProc(HWND hwnd, UINT umessage, WPARAM wparam, LPARAM lparam)`

*   Windowsê°€ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ê³³
    *   `WndProc`ì€ `InitializeWindows` í•¨ìˆ˜ë¥¼ í†µí•´ Windowsì—ê²Œ ì•Œë¦¼(`wc.lpfnWndProc = WndProc;`)
*   SystemClassì™€ ì§ì ‘ ì—°ê³„ë˜ë„ë¡ í•´ë‹¹ í´ë˜ìŠ¤ íŒŒì¼ì— í¬í•¨ë¨
    *   ëª¨ë“  ë©”ì‹œì§€ë¥¼ **SystemClass ë‚´ì˜ MessageHandler í•¨ìˆ˜ë¡œ ì „ë‹¬**í•˜ë„ë¡ ì„¤ê³„ë¨
    *   ë©”ì‹œì§€ ì²˜ë¦¬ ê¸°ëŠ¥ì´ í´ë˜ìŠ¤ ë‚´ë¶€ì— ìì—°ìŠ¤ëŸ½ê²Œ í†µí•©ë¨(+ ì½”ë“œê°€ ê¹”ë”í•˜ê²Œ ìœ ì§€)



<br>

## Inputclass

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: inputclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _INPUTCLASS_H_
#define _INPUTCLASS_H_


////////////////////////////////////////////////////////////////////////////////
// Class name: InputClass
////////////////////////////////////////////////////////////////////////////////
class InputClass
{
public:
	InputClass();
	InputClass(const InputClass&);
	~InputClass();

	void Initialize();

	void KeyDown(unsigned int);
	void KeyUp(unsigned int);

	bool IsKeyDown(unsigned int);

private:
	bool m_keys[256];
};

#endif

```

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: inputclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "inputclass.h"


InputClass::InputClass()
{
}


InputClass::InputClass(const InputClass& other)
{
}


InputClass::~InputClass()
{
}


void InputClass::Initialize()
{
	int i;
	

	// ëª¨ë“  í‚¤ì˜ ìƒíƒœ ì´ˆê¸°í™”(released)
	for(i=0; i<256; i++)
	{
		m_keys[i] = false;
	}

	return;
}


void InputClass::KeyDown(unsigned int input)
{
	// íŠ¹ì • í‚¤ê°€ ëˆŒë ¸ì„ ê²½ìš°, ìƒíƒœë¥¼ pressedë¡œ ì €ì¥
	m_keys[input] = true;
	return;
}


void InputClass::KeyUp(unsigned int input)
{
	// íŠ¹ì • í‚¤ê°€ í•´ì œë˜ì—ˆì„ ê²½ìš°, ìƒíƒœë¥¼ releasedë¡œ ì €ì¥
	m_keys[input] = false;
	return;
}


bool InputClass::IsKeyDown(unsigned int key)
{
	// íŠ¹ì • í‚¤ì˜ ëˆŒë¦¼ ì—¬ë¶€ ë°˜í™˜(true:ëˆŒë¦¼ / false:í•´ì œ)
	return m_keys[key];
}

```



InputClassëŠ” í‚¤ë³´ë“œì—ì„œ ì‚¬ìš©ì ì…ë ¥ì„ ì²˜ë¦¬í•œë‹¤. 

*   `SystemClass::MessageHandler` í•¨ìˆ˜ë¡œë¶€í„° ì…ë ¥ì„ ë°›ìŒ
*   í‚¤ë³´ë“œ ë°°ì—´(`m_key[256]`)ì„ ì‚¬ìš©í•´ ê° í‚¤ì˜ ìƒíƒœ ì €ì¥
    *   ì´í›„, í˜¸ì¶œ í•¨ìˆ˜ì—ì„œ íŠ¹ì • í‚¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•  ë•Œ, í•´ë‹¹ í‚¤ê°€ ëˆŒë ¸ëŠ”ì§€ë¥¼ ë°˜í™˜

*DirectInputì´ ë” íš¨ê³¼ì ì¸ ì…ë ¥ ë°©ì‹ì´ë‹¤! íŠœí† ë¦¬ì–¼ì„ ê°„ë‹¨íˆ í•˜ê¸° ìœ„í•´ Window ì…ë ¥ ì‚¬ìš©í•¨*

<br>

## Applicationclass.h

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _APPLICATIONCLASS_H_
#define _APPLICATIONCLASS_H_


//////////////
// INCLUDES //
//////////////
#include <windows.h>


/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = false;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 1000.0f;
const float SCREEN_NEAR = 0.3f;
We'll need these four globals to start with.

////////////////////////////////////////////////////////////////////////////////
// Class name: ApplicationClass
////////////////////////////////////////////////////////////////////////////////
class ApplicationClass
{
public:
	ApplicationClass();
	ApplicationClass(const ApplicationClass&);
	~ApplicationClass();

	bool Initialize(int, int, HWND);
	void Shutdown();
	bool Frame();

private:
	bool Render();

private:

};

#endif
```

ApplicationClassëŠ” ì‹œìŠ¤í…œ í´ë˜ìŠ¤ì—ì„œ ìƒì„±ë˜ëŠ” ê°ì²´ ì¤‘ í•˜ë‚˜ë‹¤.

*   ê·¸ë˜í”½ ê´€ë ¨ ê¸°ìˆ  ìº¡ìŠí™”
    *   ëª¨ë“  ê·¸ë˜í”½ ê¸°ìˆ ì´ ApplicationClassì— í¬í•¨ë¨
*   ì „ì²´ í™”ë©´/ì°½ í™”ë©´ ë“± ê·¸ë˜í”½ê³¼ ê´€ë ¨ëœ ì „ì—­ ì„¤ì • ì •ì˜

*í–¥í›„ íŠœí† ë¦¬ì–¼ì—ì„œ ê·¸ë˜í”½ ê°ì²´ê°€ í¬í•¨ë  ì˜ˆì •ì´ë‹¤!*

<br>

## Applicationclass.cpp

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "applicationclass.h"


ApplicationClass::ApplicationClass()
{
}


ApplicationClass::ApplicationClass(const ApplicationClass& other)
{
}


ApplicationClass::~ApplicationClass()
{
}


bool ApplicationClass::Initialize(int screenWidth, int screenHeight, HWND hwnd)
{

	return true;
}


void ApplicationClass::Shutdown()
{

	return;
}


bool ApplicationClass::Frame()
{

	return true;
}


bool ApplicationClass::Render()
{

	return true;
}
```

*ë¹ˆ Applicationclass êµ¬í˜„ë¶€(í”„ë ˆì„ì›Œí¬ë¥¼ êµ¬ì¶•í•˜ëŠ” ì¤‘).*

<br>

## Summary

*   í”„ë ˆì„ì›Œí¬ì™€ ì°½ í™”ë©´ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
*   ëª¨ë“  íŠœí† ë¦¬ì–¼ì˜ ê¸°ë°˜ì´ ë˜ë¯€ë¡œ, ìœ„ ì‘ì—…ì„ ì´í•´í•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”í•¨!
*   í•´ë‹¹ ì½”ë“œê°€ ì»´íŒŒì¼ë˜ê³  ì œëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•  ê²ƒ

<br>

## To Do Exercises

1.   `applicationclass.h`ì—ì„œ `FULL_SCREEN`ì„ `true`ë¡œ ë³€ê²½í•œ í›„ í”„ë¡œê·¸ë¨ì„ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•´ë³´ì.

     *ì°½ì´ í‘œì‹œë˜ë©´ `ESC`ë¥¼ ëˆŒëŸ¬ í”„ë¡œê·¸ë¨ ì¢…ë£Œ*

<br>

## ê²°ê³¼

![Image](https://github.com/user-attachments/assets/cb73a7c6-0169-4671-a736-6986783d6a40)

