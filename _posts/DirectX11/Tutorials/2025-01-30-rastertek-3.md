---
title: "[RasterTek/DirectX 11] #3 DirectX 11 ì´ˆê¸°í™”"

date: 2025-01-30 00:00:00 +0900
author: yejin

categories: [DirectX 11, Tutorials]
tags: [RasterTek, tuto]

mermaid: true
---

> **ğŸ“– ì°¸ê³ ìë£Œ**
>
> * [RasterTek - DirectX 11 on Windows 10 Tutorials](https://rastertek.com/tutdx11win10.html)
>
> <br>
> 
> **ğŸ–¥ï¸ ê°œë°œí™˜ê²½**
> 
> *   Window 11
> *   Visual Studio 2022
>

<br>

## Updated Framework


```mermaid
---
title: Framework
config:
  look: handDrawn
  theme: neutral
---
graph TD
	WinMain --- SystemClass
	SystemClass --- InputClass
	SystemClass --- ApplicationClass
    ApplicationClass --- D3DClass

```
Direct3D ê¸°ëŠ¥ì„ ì²˜ë¦¬í•˜ëŠ” ìƒˆ í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•œë‹¤(`D3DClass`).

ApplicationClass ë‚´ë¶€ì— ê·¸ë˜í”½ ê´€ë ¨ í´ë˜ìŠ¤ê°€ ìº¡ìŠí™”ë˜ë¯€ë¡œ, D3DClassë„ ApplicationClass ë‚´ë¶€ì— í¬í•¨ëœë‹¤. 

<br>

## ApplicationClass.h

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename:  applicationclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _APPLICATIONCLASS_H_
#define _APPLICATIONCLASS_H_
```

```c++
///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "d3dclass.h"

/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = false;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 1000.0f;
const float SCREEN_NEAR = 0.3f;


////////////////////////////////////////////////////////////////////////////////
// Class name: ApplicationClass
////////////////////////////////////////////////////////////////////////////////
class ApplicationClass
{
public:
	ApplicationClass();
	ApplicationClass(const ApplicationClass&);
	~ApplicationClass();

	bool Initialize(int, int, HWND);
	void Shutdown();
	bool Frame();

private:
	bool Render();

private:
	D3DClass* m_Direct3D;
};

#endif
```

**ë³€ê²½ì **

1.   `windows.h` ëŒ€ì‹  `d3dclass.h`ë¥¼ include
2.   D3DClassì˜ ìƒˆ private í¬ì¸í„°(`m_Direct3D`) ì¶”ê°€
     *   `m_`: í´ë˜ìŠ¤ ë©¤ë²„ ë³€ìˆ˜ì¸ì§€ êµ¬ë³„

<br>

## ApplicationClass.cpp

```c++
#include "applicationclass.h"


ApplicationClass::ApplicationClass()
{
	m_Direct3D = 0;
}


ApplicationClass::ApplicationClass(const ApplicationClass& other)
{
}


ApplicationClass::~ApplicationClass()
{
}


bool ApplicationClass::Initialize(int screenWidth, int screenHeight, HWND hwnd)
{
	bool result;

	// D3D ê°ì²´ ìƒì„± ë° ì´ˆê¸°í™”
	m_Direct3D = new D3DClass;

	result = m_Direct3D->Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR);

	if (!result)
	{
		MessageBox(hwnd, L"Could not initialize Direct3D", L"Error", MB_OK);
		return false;
	}

	return true;
}


void ApplicationClass::Shutdown()
{
	// D3D ê°ì²´ í•´ì œ

	if (m_Direct3D)
	{
		m_Direct3D->Shutdown();
		delete m_Direct3D;
		m_Direct3D = 0;
	}

	return;
}


bool ApplicationClass::Frame()
{
	bool result;

	// ê·¸ë˜í”½ ë Œë”ë§
	result = Render();
	if (!result)
	{
		return false;
	}

	return true;
}


bool ApplicationClass::Render()
{
	// ë²„í¼ë¥¼ ë¹„ìš°ê³  scene ì‹œì‘
	m_Direct3D->BeginScene(0.5f, 0.5f, 0.5f, 1.0f);

	// ë Œë”ë§ëœ sceneì„ í™”ë©´ì— í‘œì‹œ
	m_Direct3D->EndScene();

	return true;
}
```

**ë³€ê²½ì **

1.   ìƒì„±ì

     *   í¬ì¸í„° `nullptr` ì´ˆê¸°í™”

         *í¬ì¸í„°ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ë ¤ë©´ ë³€ìˆ˜ë¥¼ í•­ìƒ ì´ˆê¸°í™”í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤!*

2.   `Initialize`

     *   D3DClass ê°ì²´ë¥¼ ìƒì„±í•˜ê³  ì´ˆê¸°í™” í•¨ìˆ˜ í˜¸ì¶œ	
         *   í™”ë©´ ë„ˆë¹„, ë†’ì´, í•¸ë“¤, `ApplicationClass`ì „ì—­ ë³€ìˆ˜ ì „ë‹¬
         *   D3Dê°€ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì•„ D3D System ì„¤ì •

3.   `shutdown`

     *   D3DClass ì¢…ë£Œ ì½”ë“œ ì¶”ê°€

         *ëª¨ë“  ê·¸ë˜í”½ ê°ì²´ëŠ” ì´ í•¨ìˆ˜ì—ì„œ ì¢…ë£Œëœë‹¤!*

     *   í¬ì¸í„°ë¥¼ `nullptr`ë¡œ ì´ˆê¸°í™”

         *   í¬ì¸í„°ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ë‹¤ë©´ í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë˜ì§€ ì•ŠìŒ

         *   í¬ì¸í„°ê°€ ìœ íš¨í•œ ê²½ìš° `shutdown()`ì„ í˜¸ì¶œí•˜ê³ , ë©”ëª¨ë¦¬ í•´ì œ

             *ë§Œì•½, ì´ë¯¸ `nullptr`ì´ë©´ ì•„ì§ ê°ì²´ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ, ë¶ˆí•„ìš”í•œ shutdown í˜¸ì¶œx*

4.   `Frame`
     *   ê° í”„ë ˆì„ë§ˆë‹¤ `Render` í•¨ìˆ˜ í˜¸ì¶œ => ê·¸ë˜í”½ ë Œë”ë§
5.   `Render`
     *   D3Dë¥¼ ì‚¬ìš©í•´ í™”ë©´ì„ íšŒìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
     *   ì´ˆê¸°í™” í›„ `EndScene`ì„ í˜¸ì¶œí•´ ë Œë”ë§ëœ ì”¬ì„ ìœˆë„ìš°ì— í‘œì‹œ

<br>

## D3dclass.h

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: d3dclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _D3DCLASS_H_
#define _D3DCLASS_H_
```

<br>

### LINKING

```c++
/////////////
// LINKING //
/////////////
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "d3dcompiler.lib")
```

**í—¤ë”ì—ì„œ ì²« ë²ˆì§¸ë¡œ í•  ì¼**: ì˜¤ë¸Œì íŠ¸ ëª¨ë“ˆì„ ì‚¬ìš©í•  ë•Œ ë§í¬í•  ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§€ì •

1.   `d3d11.lib`: D3Dì˜ ëª¨ë“  ê¸°ëŠ¥ í¬í•¨
     *   DX11ì—ì„œ 3D ê·¸ë˜í”½ì„ ì„¤ì •í•˜ê³  ê·¸ë¦¬ëŠ”ë° ì‚¬ìš©
2.   `dxgi.lib`: ì»´í“¨í„°ì˜ í•˜ë“œì›¨ì–´ì™€ ìƒí˜¸ì‘ìš©í•˜ëŠ” ë„êµ¬ í¬í•¨
     *   ëª¨ë‹ˆí„°ì˜ ì£¼ì‚¬ìœ¨(refresh rate), ê·¸ë˜í”½ì¹´ë“œ ì •ë³´ ë“±ì„ ì œê³µë°›ìŒ
3.   `d3dcompiler.lib`: ì…°ì´ë” ì»´íŒŒì¼ ê¸°ëŠ¥ í¬í•¨

<br>

### INCLUDE

```c++
#include <d3d11.h>
#include <directxmath.h>
using namespace DirectX;
```

*   `d3d11.h`: ì˜¤ë¸Œì íŠ¸ ëª¨ë“ˆì— ë§í¬í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬

*   `directxmath.h`: DX íƒ€ì… ì •ì˜, ìˆ˜í•™ ì—°ì‚° ê¸°ëŠ¥

    *e.g.) ìˆ˜í•™ ì—°ì‚°, ê·¸ë˜í”½ ë°ì´í„° ë“± -> ë²¡í„°, í–‰ë ¬, ì¢Œí‘œ, ìƒ‰ìƒ ë“±*

<br>

```c++
class D3DClass
{
public:
	D3DClass();
	D3DClass(const D3DClass&);
	~D3DClass();

	/* D3D ì´ˆê¸°í™” ë° í•´ì œ */
	bool Initialize(int, int, bool, HWND, bool, float, float);	 // D3D ì´ˆê¸°í™”
	void Shutdown();	// D3D ê°ì²´/ë©”ëª¨ë¦¬ í•´ì œ

	/* getter / setter */ 
	
	// Scene ì‹œì‘ ë° ì¶œë ¥
	void BeginScene(float, float, float, float);	// í™”ë©´ ê·¸ë¦¬ê¸° ì „, ë²„í¼ ì´ˆê¸°í™”
	void EndScene();	// ë Œë”ë§ í›„ ë²„í¼ ì¶œë ¥

	ID3D11Device* GetDevice();	// D3D ë””ë°”ì´ìŠ¤ ê°ì²´(ê·¸ë˜í”½ ë¦¬ì†ŒìŠ¤ ìƒì„±)
	ID3D11DeviceContext* GetDeviceContext();	// D3D ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸(íŒŒì´í”„ë¼ì¸ ìŠ¤í…Œì´ì§€ë¡œ ì ‘ê·¼í•´ GPUì— ë Œë”ë§ ëª…ë ¹)

	// í–‰ë ¬ ë°˜í™˜
	void GetProjectionMatrix(XMMATRIX&);	// 3D íˆ¬ì˜ í–‰ë ¬
	void GetWorldMatrix(XMMATRIX&);			// 3D ì›”ë“œ ë³€í™˜ í–‰ë ¬(3D ì˜¤ë¸Œì íŠ¸ ìœ„ì¹˜ ë° íšŒì „ ë³€í™˜)
	void GetOrthoMatrix(XMMATRIX&);			// 2D ì§êµ í–‰ë ¬ (2D ë Œë”ë§ ìœ„í•¨)

	void GetVideoCardInfo(char* cardName, int& memory);	// ë¹„ë””ì˜¤ ì¹´ë“œ ì •ë³´(ì´ë¦„, í¬ê¸°)
	
	void SetBackBufferRenderTarget();	// ë°± ë²„í¼ë¥¼ í˜„ì¬ ë Œë” íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì •(ë Œë”ë§ ëŒ€ìƒ)
    
	void ResetViewport();	// ë·°í¬íŠ¸ ì´ˆê¸°í™”(í¬ê¸°, ìœ„ì¹˜)

private:
	bool m_vsync_enabled;	// ìˆ˜ì§ ë™ê¸°í™” í™œì„±í™”

	int m_videoCardMemory;	// ë¹„ë””ì˜¤ ì¹´ë“œ ë©”ëª¨ë¦¬(mb)
	char m_videoCardDescription[128];	// ë¹„ë””ì˜¤ ì¹´ë“œ ì´ë¦„

	IDXGISwapChain* m_swapChain;	// ìŠ¤ì™‘ ì²´ì¸(ë”ë¸” ë²„í¼ë§ìš©)

	ID3D11Device* m_device;	// D3D ë””ë°”ì´ìŠ¤ ê°ì²´ (GPUë¦¬ì†ŒìŠ¤ ê´€ë¦¬)
	ID3D11DeviceContext* m_deviceContext;	// D3D ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ (ì´ì¹œêµ¬ê°€ ë Œë”ë§ ëª…ë ¹ ë‚´ë¦¼)

	ID3D11RenderTargetView* m_renderTargetView;	// ë Œë” íƒ€ê²Ÿ ë·°(ë Œë”ë§ ì¶œë ¥)
	
	ID3D11Texture2D* m_depthStencilBuffer;	// ê¹Šì´ ìŠ¤í…ì‹¤ ë²„í¼
	ID3D11DepthStencilState* m_depthStencilState;	// ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœ
	ID3D11DepthStencilView* m_depthStencilView;	// ê¹Šì´ ìŠ¤í…ì‹¤ ë·°

	ID3D11RasterizerState* m_rasterState;	// ë˜ìŠ¤í„°ë¼ì´ì € ìƒíƒœ(ì»¬ë§, ì™€ì´ì–´í”„ë ˆì„ ë“±)

	XMMATRIX m_projectionMatirx;	// íˆ¬ì˜ í–‰ë ¬
	XMMATRIX m_worldMatrix;	// ì›”ë“œ í–‰ë ¬
	XMMATRIX m_orthoMatrix;	// ì§êµ í–‰ë ¬

	D3D11_VIEWPORT m_viewport;	// ë·°í¬íŠ¸ ì„¤ì •(êµ¬ì¡°ì²´)
};

#endif
```

D3DClassì˜ í´ë˜ìŠ¤ ì •ì˜ëŠ” ìµœëŒ€í•œ ê°„ë‹¨í•˜ê²Œ ì‘ì„±ë˜ì—ˆë‹¤.

*   ê¸°ë³¸ ìƒì„±ì, ë³µì‚¬ ìƒì„±ì, ì†Œë©¸ì

ì´ë²ˆ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” `Initialize`, `Shutdown` í•¨ìˆ˜ë¥¼ ì¤‘ì ìœ¼ë¡œ í•œë‹¤. 

*ë·° í–‰ë ¬(View Matrix)ëŠ” ì¹´ë©”ë¼ í´ë˜ìŠ¤ì— í¬í•¨ë  ì˜ˆì •ì´ë¯€ë¡œ, í•´ë‹¹ í´ë˜ìŠ¤ì— ë³€ìˆ˜ë¥¼ ìƒì„±í•˜ì§€ ì•Šì•˜ë‹¤.*



<br>

## D3dclass.cpp

```c++
D3DClass::D3DClass()
{
	m_swapChain = 0;
	m_device = 0;
	m_deviceContext = 0;
	m_renderTargetView = 0;
	m_depthStencilBuffer = 0;
	m_depthStencilState = 0;
	m_depthStencilView = 0;
	m_rasterState = 0;
}

D3DClass::D3DClass(const D3DClass&)
{
}

D3DClass::~D3DClass()
{
}
```

ìƒì„±ìì—ì„œ ëª¨ë“  ë©¤ë²„ í¬ì¸í„° ë³€ìˆ˜ë¥¼ `null`ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤.

<br>

### Initialize

---

#### ë§¤ê°œ ë³€ìˆ˜

```c++
bool D3DClass::Initialize(int screenWidth, int screenHeight, bool vsync, HWND hwnd, bool fullscreen, float screenDepth, float screenNear)
{
	HRESULT result;
    
	IDXGIFactory* factory;
	IDXGIAdapter* adapter;
	IDXGIOutput* adapterOutput;
    
	unsigned int numModes, i, numerator, denominator;
	unsigned long long stringLength;
    
	DXGI_MODE_DESC* displayModeList;
	DXGI_ADAPTER_DESC adapterDesc;
    
	int error;
    
	DXGI_SWAP_CHAIN_DESC swapChainDesc;
    
	D3D_FEATURE_LEVEL featureLevel;
    
	ID3D11Texture2D* backBufferPtr;
	D3D11_TEXTURE2D_DESC depthBufferDesc;
    
	D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
	D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
    
	D3D11_RASTERIZER_DESC rasterDesc;
    
	float fieldOfView, screenAspect;


	// vsync ì„¤ì • ì €ì¥
	m_vsync_enabled = vsync;
```

**Initialize**: DX11 ì „ì²´ ì„¤ì •

*   ë§¤ê°œë³€ìˆ˜
    *   `ScreenWidth`: ìœˆë„ìš° ë„ˆë¹„
    *   `ScreenHeight`: ìœˆë„ìš° ë†’ì´
    *   `hwnd`: ìœˆë„ìš° í•¸ë“¤(D3Dê°€ ìœˆë„ìš°ì— ì ‘ê·¼)
    *   `fullscreen`: ì „ì²´ í™”ë©´ ëª¨ë“œ
    *   `screenDepth`: 3Dí™”ë©´ì˜ ê¹Šì´(ì›ê·¼ íˆ¬ì˜) ì„¤ì •. Z-Far
    *   `screenNear`: 3Dí™”ë©´ì˜ ê¹Šì´(ì›ê·¼ íˆ¬ì˜) ì„¤ì •. Z-Near
    *   `vsync`: ìˆ˜ì§ ë™ê¸°í™” ì„¤ì •(`t`: ì£¼ì‚¬ìœ¨ì— ë§ì¶° ë Œë”ë§, `f`: ìµœëŒ€í•œ ë¹ ë¥´ê²Œ ë Œë”ë§)

<br>

---

#### ëª¨ë‹ˆí„° ì£¼ì‚¬ìœ¨ í™•ì¸

```c++
    // DX ê·¸ë˜í”½ ì¸í„°í˜ì´ìŠ¤ íŒ©í† ë¦¬ ìƒì„±
    result = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);
    if(FAILED(result))
    {
        return false;
    }

    // íŒ©í† ë¦¬ë¥¼ ì‚¬ìš©í•´ ê¸°ë³¸ ê·¸ë˜í”½ ì¸í„°í˜ì´ìŠ¤(ë¹„ë””ì˜¤ ì¹´ë“œ) ì–´ëŒ‘í„° ìƒì„±
    result = factory->EnumAdapters(0, &adapter);
    if(FAILED(result))
    {
        return false;
    }

    // ê¸°ë³¸ ì–´íƒ­í„° ì¶œë ¥(ëª¨ë‹ˆí„°) ì—´ê±°
    result = adapter->EnumOutputs(0, &adapterOutput);
    if(FAILED(result))
    {
        return false;
    }

    // ì–´ëŒ‘í„° ì¶œë ¥(ëª¨ë‹ˆí„°)ì— ëŒ€í•´ DXGI_FORMAT_R8G8B8A8_UNORM ë””ìŠ¤í”Œë ˆì´ í¬ë§·ì„ ì§€ì›í•˜ëŠ” ëª¨ë“œ ê°œìˆ˜ ê°€ì ¸ì˜´
    result = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, NULL);
    if(FAILED(result))
    {
        return false;
    }

    // í˜„ì¬ ëª¨ë‹ˆí„°, ë¹„ë””ì˜¤ ì¹´ë“œ ì¡°í•©ì— ëŒ€í•´ ê°€ëŠ¥í•œ ëª¨ë“  ë””ìŠ¤í”Œë ˆì´ ëª¨ë“œë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
    displayModeList = new DXGI_MODE_DESC[numModes];
    if(!displayModeList)
    {
        return false;
    }

    // ë””ìŠ¤í”Œë ˆì´ ëª¨ë“œ êµ¬ì¡°ì²´ì— ì •ë³´ ì €ì¥
    result = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, displayModeList);
    if(FAILED(result))
    {
        return false;
    }

    // ëª¨ë“  ë””ìŠ¤í”Œë ˆì´ ëª¨ë“œ ê²€ì‚¬ -> í™”ë©´ ë„ˆë¹„ì™€ ë†’ì´ê°€ ì¼ì¹˜í•˜ëŠ” ëª¨ë“œ íƒìƒ‰
    // ì¼ì¹˜í•˜ëŠ” ëª¨ë“œë¥¼ ì°¾ìœ¼ë©´ -> ëª¨ë‹ˆí„° ì£¼ì‚¬ìœ¨ì˜ ë¶„ì(Numerator)ì™€ ë¶„ëª¨(Denominator)ë¥¼ ì €ì¥
    for(i=0; i<numModes; i++)
    {
        if(displayModeList[i].Width == (unsigned int)screenWidth)
        {
            if(displayModeList[i].Height == (unsigned int)screenHeight)
            {
                numerator = displayModeList[i].RefreshRate.Numerator;
                denominator = displayModeList[i].RefreshRate.Denominator;
            }
        }
    }
```

**ë¹„ë””ì˜¤ ì¹´ë“œ/ì£¼ì‚¬ìœ¨ ì •ë³´**

*   D3D ì´ˆê¸°í™” ì „, ë¹„ë””ì˜¤ ì¹´ë“œ ë° ëª¨ë‹ˆí„°ì˜ ì£¼ì‚¬ìœ¨ ì •ë³´ ìš”ì²­

    *ì™œ? ì»´í“¨í„°ë§ˆë‹¤ ì£¼ì‚¬ìœ¨ì´ ë‹¤ë¥´ë¯€ë¡œ, ì´ë¥¼ ì¿¼ë¦¬í•´ í™•ì¸í•´ì•¼ í•œë‹¤!*

    *   ë¶„ì, ë¶„ëª¨ê°’ì„ ì¿¼ë¦¬í•œ í›„, DX ì„¤ì •ì—ì„œ í•´ë‹¹ ê°’ ì „ë‹¬
        *   DXëŠ” ë¶„ì/ë¶„ëª¨ê°’ì„ í† ëŒ€ë¡œ ì •í™•í•œ ì£¼ì‚¬ìœ¨ì„ ê³„ì‚°

    ğŸŒ± *ë§Œì•½, ì£¼ì‚¬ìœ¨ ê³„ì‚° ê³¼ì •ì„ ìƒëµí•œë‹¤ë©´(ê¸°ë³¸ê°’ ì„¤ì •)?*

    => DXê°€ ë²„í¼ í”Œë¦½ ëŒ€ì‹  blitì„ ìˆ˜í–‰í•´ ë Œë”ë§ ì„±ëŠ¥ ì €í•˜, ë””ë²„ê·¸ ì¶œë ¥ì— ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

>   ğŸ’¡ **Buffer filp** VS **blit**
>
>   *   buffer filp(`DXGI_SWAP_EFFECT_FLIP_DISCARD`): í”„ë¡ íŠ¸ ë²„í¼ì™€ ë°± ë²„í¼ ìŠ¤ìœ„ì¹­
>
>   *   blit(`DXGI_SWAP_EFFECT_DISCARD`): í”„ë ˆì„ì„ ì§ì ‘ ë³µì‚¬í•´ í™”ë©´ì— ê·¸ë¦¼
>
>   
>
>   BitBlit ëª¨ë¸ì€ ë©”ëª¨ë¦¬ë¥¼ ì§ì ‘ ë³µì‚¬ì— í™”ë©´ì— ê·¸ë¦¬ê¸° ë•Œë¬¸ì— GPU ì—°ì‚°ì´ ë¶€ê³¼ëœë‹¤. 
>
>   GPU ì—°ì‚° ë¶€ë‹´ì„ ë‚®ì¶”ê¸° ìœ„í•´ UWP ì• í”Œë¦¬ì¼€ì´ì…˜ì€ Flip ìŠ¤ì™‘ì„ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •ë˜ì–´ ìˆë‹¤. `DXGI_SWAP_EFFECT_DISCARD`ë¥¼ ì‚¬ìš©í•  ê²½ìš°, UWP í™˜ê²½ìœ¼ë¡œ í¬íŒ…í•˜ë©´ Win32 í™˜ê²½ê³¼ ë‹¤ë¥´ê²Œ ë™ì‘í•  ìˆ˜ ìˆë‹¤. => GPU ì„±ëŠ¥ ì €í•˜ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤.
>
>   <br>
>
>   ì°¸ê³ : 
>
>   [**Microsoft Learn**: BitBlt function (wingdi.h)](https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt)
>
>   [**Microsoft Learn**: DXGI_SWAP_EFFECT enumeration (dxgi.h)](https://learn.microsoft.com/en-us/windows/win32/api/dxgi/ne-dxgi-dxgi_swap_effect)

<br>

---

#### ë¹„ë””ì˜¤ ì¹´ë“œ ì •ë³´

```c++
    // ì–´ëŒ‘í„°(ë¹„ë””ì˜¤ ì¹´ë“œ) ì„¤ëª… ì •ë³´ ê°€ì ¸ì˜´
    result = adapter->GetDesc(&adapterDesc);
    if(FAILED(result))
    {
        return false;
    }

    // ë¹„ë””ì˜¤ ì¹´ë“œ ë©”ëª¨ë¦¬ ì €ì¥(ë‹¨ìœ„: megabytes)
    m_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024);

    // ë¹„ë””ì˜¤ ì¹´ë“œ ì´ë¦„ì„ char ë°°ì—´ë¡œ ë³€í™˜ í›„ ì €ì¥
    error = wcstombs_s(&stringLength, m_videoCardDescription, 128, adapterDesc.Description, 128);
    if(error != 0)
    {
        return false;
    }
```

ì–´ëŒ‘í„°ë¥¼ ì‚¬ìš©í•´ ë¹„ë””ì˜¤ ë©”ëª¨ë¦¬ í¬ê¸°(`m_videoCardMemory`)ì™€ ì´ë¦„(`m_videoCardDescription`)ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë‹¤.

<br>

---

#### ì‚¬ìš©í•œ êµ¬ì¡°ì²´ì™€ ì¸í„°í˜ì´ìŠ¤ í•´ì œ

```c++
    // ë””ìŠ¤í”Œë ˆì´ ëª¨ë“œ ë¦¬ìŠ¤íŠ¸ í•´ì œ
    delete [] displayModeList;
    displayModeList = 0;

    // ì–´ëŒ‘í„° ì¶œë ¥ í•´ì œ
    adapterOutput->Release();
    adapterOutput = 0;

    // ì–´ëŒ‘í„° í•´ì œ
    adapter->Release();
    adapter = 0;

    // DXGI íŒ©í† ë¦¬ í•´ì œ
    factory->Release();
    factory = 0;
```

ì£¼ì‚¬ìœ¨ ë¶„ì, ë¶„ëª¨ ê°’ê³¼ ë¹„ë””ì˜¤ì¹´ë“œ ì •ë³´ë¥¼ ì €ì¥í–ˆìœ¼ë¯€ë¡œ, ì •ë³´ë¥¼ ì–»ê¸° ìœ„í•´ ì‚¬ìš©í–ˆë˜ êµ¬ì¡°ì²´ì™€ ì¸í„°í˜ì´ìŠ¤ë¥¼ í•´ì œí•œë‹¤.

<br>

---

#### ìŠ¤ì™‘ ì²´ì¸ ì´ˆê¸°í™”

```c++
    // ìŠ¤ì™‘ ì²´ì¸ Desc ì´ˆê¸°í™”
    ZeroMemory(&swapChainDesc, sizeof(swapChainDesc));

    // ì‹±ê¸€ ë°± ë²„í¼ ì„¤ì •
    swapChainDesc.BufferCount = 1;

    // ë°± ë²„í¼ì˜ ë„ˆë¹„ ë° ë†’ì´ ì„¤ì •
    swapChainDesc.BufferDesc.Width = screenWidth;
    swapChainDesc.BufferDesc.Height = screenHeight;

    // ë°± ë²„í¼ì˜ ìƒ‰ìƒ í˜•ì‹ì„ ì¼ë°˜ 32-bitìœ¼ë¡œ ì§€ì •
    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
```

**SwapChainDesc**

*   `SwapChain`: í”„ë¡ íŠ¸ ë²„í¼ - ë°± ë²„í¼ë¥¼ í¬í•¨í•˜ëŠ” êµ¬ì¡°
    *   ë°± ë²„í¼ì—ì„œ ë Œë”ë§í•œ í›„ í”„ë¡ íŠ¸ ë²„í¼ë¡œ ìŠ¤ì™‘í•´ í™”ë©´ì— í‘œì‹œ 

<br>

---

#### ì£¼ì‚¬ìœ¨(Refresh rate) ì„¤ì •

```c++
// ë°± ë²„í¼ì˜ ì£¼ì‚¬ìœ¨ ì„¤ì •
if (m_vsync_enabled)
{
	swapChainDesc.BufferDesc.RefreshRate.Numerator = numerator;
	swapChainDesc.BufferDesc.RefreshRate.Denominator = denominator;
}
else
{
	swapChainDesc.BufferDesc.RefreshRate.Numerator = 0;
	swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
}
```

ì£¼ì‚¬ìœ¨: ë°± ë²„í¼ë¥¼ í”„ë¡ íŠ¸ ë²„í¼ë¡œ ì´ˆë‹¹ ëª‡ ë²ˆ ì „í™˜í•˜ëŠ”ì§€ ë‚˜íƒ€ë‚´ëŠ” ë¹„ìœ¨

*   `vsync == true`
    *   ì£¼ì‚¬ìœ¨ì´ ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¦„ (*e.g.) 60Hz*)
*   `vsync == false`
    *   DXê°€ ì£¼ì‚¬ìœ¨ì„ ë¬´ì‹œí•˜ê³  ìµœëŒ€í•œ ë¹ ë¥¸ ì†ë„ë¡œ í™”ë©´ ê°±ì‹ 
    *   ë‹¨, ì‹œê°ì  ì•„í‹°íŒ©íŠ¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ (*e.g. Screen Tearing*)

>   ğŸ’¡ **Hz** VS **FPS**
>
>   *   ì£¼ì‚¬ìœ¨(*Hz*): ëª¨ë‹ˆí„°ê°€ 1ì´ˆë§ˆë‹¤ í™”ë©´ì— ìƒì„±í•˜ëŠ” ì´ë¯¸ì§€ ê°œìˆ˜
>   *   í”„ë ˆì„ ë ˆì´íŠ¸(*FPS*): GPUê°€ 1ì´ˆë§ˆë‹¤ ìƒì„±í•˜ëŠ” í”„ë ˆì„ ê°œìˆ˜



<br>

---

#### ìŠ¤ì™‘ ì²´ì¸ ì„¤ì •

```c++
	// ë°± ë²„í¼ì˜ ì‚¬ìš© ëª©ì  ì„¤ì •
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;	// ë Œë” íƒ€ê²Ÿ ì¶œë ¥(GPUê°€ ë°± ë²„í¼ì— ê·¸ë¦¬ê¸° ê°€ëŠ¥)

	// ë Œë”ë§í•  ìœˆë„ìš° í•¸ë“¤ ì„¤ì •
	swapChainDesc.OutputWindow = hwnd;
	
	// ë©€í‹° ìƒ˜í”Œë§ ë¹„í™œì„±í™”
	swapChainDesc.SampleDesc.Count = 1;
	swapChainDesc.SampleDesc.Quality = 0;


	// Fullscreen | Windowed ì„¤ì •
	if (fullscreen)
	{
		swapChainDesc.Windowed = false;
	}
	else
	{
		swapChainDesc.Windowed = true;
	}

	// scan line ìˆœì„œ ë° ìŠ¤ì¼€ì¼ë§ì„ ë¯¸ì§€ì •ìœ¼ë¡œ ì„¤ì •
	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	// ì‚¬ìš© í›„ ë°± ë²„í¼ ë‚´ìš© ì‚­ì œ
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	// ê³ ê¸‰ í”Œë˜ê·¸ ì„¤ì •x
	swapChainDesc.Flags = 0;
```

[**DXGI_USAGE**](https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/dxgi-usage): ë°± ë²„í¼ì˜ ì‚¬ìš© ëª©ì  ì„¤ì •

*   `DXGI_USAGE_BACK_BUFFER`: ë°± ë²„í¼ ì‚¬ìš©
    *   *ìŠ¤ì™‘ ì²´ì¸ì„ ì‚¬ìš©í•  ë•Œ í•´ë‹¹ í”Œë˜ê·¸ë¥¼ ì „ë‹¬í•  í•„ìš”ëŠ” ì—†ì§€ë§Œ, ë¦¬ì†ŒìŠ¤ê°€ ìŠ¤ì™‘ ì²´ì¸ì— ì†í•´ ìˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤!*
*   `DXGI_USAGE_DISCARD_ON_PRESENT`: ìƒˆ í”„ë ˆì„ì„ ê·¸ë¦° í›„ ë°± ë²„í¼ëŠ” ìë™ ì‚­ì œ
*   `DXGI_USAGE_READ_ONLY`: ë¦¬ì†ŒìŠ¤ë¥¼ ì½ê¸° ì „ìš© ë¦¬ì†ŒìŠ¤ë¡œ ì‚¬ìš©
*   `DXGI_USAGE_RENDER_TARGET_OUTPUT`: GPUê°€ ë Œë”ë§ íƒ€ê²Ÿ/ë¦¬ì†ŒìŠ¤ë¥¼ ì¶œë ¥ (í™”ë©´ì— í‘œì‹œí•  ë°± ë²„í¼)
*   `DXGI_USAGE_SHADER_INPUT`: ì…°ì´ë”ì—ì„œ ì‚¬ìš©í•˜ëŠ” í…ìŠ¤ì²˜, ë²„í¼ ë°ì´í„°
*   `DXGI_USAGE_SHARED`: ë Œë” íƒ€ê²Ÿì´ë‚˜ ë¦¬ì†ŒìŠ¤ ê³µìœ 
*   `DXGI_USAGE_UNORDERED_ACCESS`: GPUë¡œ ì—°ì‚°í•˜ê¸° ìœ„í•´ ì ‘ê·¼ ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤
    *   *GPU ë³‘ë ¬ ì—°ì‚° -> ìˆœì„œë¥¼ ê³ ë ¤í•˜ì§€ ì•Šê³  ë¹ ë¥´ê²Œ ë°ì´í„° ì½ê³  ì“¸ ìˆ˜ ìˆë„ë¡!*

<br>

---

#### Feature Level

```c++
	// DX11ì„ Feature Levelë¡œ ì§€ì •
	featureLevel = D3D_FEATURE_LEVEL_11_0;
```

**Feature Level**

*   DirectXì—ì„œ ì‚¬ìš©í•  ë²„ì „ ì„ íƒ

<br>

---

#### swap chain, D3D device ìƒì„±

```c++
// ìŠ¤ì™‘ ì²´ì¸, D3D ë””ë°”ì´ìŠ¤, D3D ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
result = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0,
                                       &featureLevel, 1, D3D11_SDK_VERSION,
                                       &swapChainDesc, &m_swapChain, &m_device, NULL, &m_deviceContext);
if (FAILED(result))
{
	return false;
}
```



ì•ì„œ ìŠ¤ì™‘ ì²´ì¸ê³¼ Feature Levelì„ ì„¤ì •ì„ ì™„ë£Œí–ˆë‹¤. ìŠ¤ì™‘ ì²´ì¸ê³¼ Direct3D ë””ë°”ì´ìŠ¤, ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

Direct3D ë””ë°”ì´ìŠ¤, ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ëŠ” ëª¨ë“  Direct3D í•¨ìˆ˜ì— ëŒ€í•œ ì¸í„°í˜ì´ìŠ¤ê°€ ëœë‹¤. ë§¤ìš° ì¤‘ìš”í•œ ê¸°ëŠ¥ì„!

ê±°ì˜ ëª¨ë“  ê·¸ë˜í”½ ì½”ë”© ê³¼ì •ì—ì„œ ë””ë°”ì´ìŠ¤ì™€ ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.

<br>

DX11 ì´ì „ ë²„ì „ì„ ì‚¬ìš©í–ˆë‹¤ë©´, Direct3D ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ëŠ” ìƒì†Œí•  ê²ƒì´ë‹¤. ì´ì „ ë²„ì „ì˜ ê¸°ì¡´ ê¸°ëŠ¥ì„ ë””ë°”ì´ìŠ¤ì™€ ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¡œ ë¶„ë¦¬í–ˆê¸° ë•Œë¬¸. 

ë‘ ê¸°ëŠ¥ì„ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

<br>

DirectX 11 ê·¸ë˜í”½ ì¹´ë“œê°€ ì—†ì„ ê²½ìš°, í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë„ ë””ë°”ì´ìŠ¤ì™€ ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ë‹¤.

ê·¸ë˜í”½ ì¹´ë“œê°€ ì—†ë‹¤ë©´, `D3D_DRIVER_TYPE_HARDWARE`ë¥¼ `D3D_DRIVER_TYPE_REFERENCE`ë¡œ ë°”ê¾¸ì–´ CPUê°€ ëŒ€ì‹  ë Œë”ë§í•˜ë„ë¡ ì„¤ì •í•  ìˆ˜ ìˆë‹¤. *(ë‹¨, ì„±ëŠ¥ì´ 1/1000 ì •ë„ë‹¤.)*

<br>

ë””ë°”ì´ìŠ¤ë¥¼ ìƒì„±í•  ë•Œ, ì£¼ ê·¸ë˜í”½ ì¹´ë“œê°€ DirectX11ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì‹¤íŒ¨í•  ìˆ˜ ìˆë‹¤.

1.   ì£¼ ê·¸ë˜í”½ ì¹´ë“œê°€DirectX10, ë³´ì¡° ê·¸ë˜í”½ ì¹´ë“œê°€ DirectX11ì¸ ê²½ìš°

2.   ì¼ë¶€ í•˜ì´ë¸Œë¦¬ë“œ ê·¸ë˜í”½ ì¹´ë“œ*(ì£¼ë¥¼ ì €ì „ë ¥ Intel, ë³´ì¡°ë¥¼ ê³ ì „ë ¥ Nvidiaë¡œ ì‚¬ìš©í•  ê²½ìš°)*

ì´ë¥¼ í•´ê²°í•˜ë ¤ë©´ ê¸°ë³¸ ë””ë°”ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ëª¨ë“  ê·¸ë˜í”½ ì¹´ë“œë¥¼ ë‚˜ì—´í•œ í›„, ì‚¬ìš©ìê°€ ì§ì ‘ GPUë¥¼ ì„ íƒí•´ì•¼ í•œë‹¤.

<br>

---

#### Back Buffer



```c++
	// ë°± ë²„í¼ í¬ì¸í„° ê°€ì ¸ì˜´
	result = m_swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&backBufferPtr);
	if (FAILED(result))
	{
		return false;
	}

	// ë°± ë²„í¼ë¥¼ ë Œë” íƒ€ê²Ÿ ë·°ë¡œ ì„¤ì •
	result = m_device->CreateRenderTargetView(backBufferPtr, NULL, &m_renderTargetView);
	if (FAILED(result))
	{
		return false;
	}

	// ë°± ë²„í¼ í¬ì¸í„° ë³€ìˆ˜ê°€ ë”ì´ìƒ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í•´ì œ
	backBufferPtr->Release();
	backBufferPtr = 0;
```

ì°¨í›„ ë²„í¼ ìŠ¤ì™‘ì„ ìœ„í•´, ë°± ë²„í¼ì˜ í¬ì¸í„°ë¥¼ ìŠ¤ì™‘ ì²´ì¸ì— ì—°ê²°í•´ì•¼ í•œë‹¤.

*   `CreateRenderTargetView` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë°± ë²„í¼ë¥¼ ë Œë” íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì •
*   ë Œë” íƒ€ê²Ÿ ë·°ê°€ ìƒì„±ë˜ë©´ ë°± ë²„í¼ í¬ì¸í„°ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, í¬ì¸í„° ë³€ìˆ˜ í•´ì œ
    *   `Release()` í˜¸ì¶œ ì‹œ DirectX ë‚´ë¶€ì—ì„œ ì°¸ì¡° ì¹´ìš´íŠ¸ ê°ì†Œ*(ë©”ëª¨ë¦¬ ì •ë¦¬)*

<br>

>   ğŸŒ± *ë Œë” íƒ€ê²Ÿ ë·° (Render Target View)*
>
>   *   ë°± ë²„í¼ëŠ” ë©”ëª¨ë¦¬ì—ë§Œ ì¡´ì¬í•˜ë¯€ë¡œ, ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
>   *   ë Œë”ë§ì„ ìœ„í•´ ë°± ë²„í¼ë¥¼ ë Œë” íƒ€ê²Ÿ ë·°ë¡œ ì„¤ì • (`CreateRenderTargetView`)
>       *   *ë Œë” íƒ€ê²Ÿ(ë Œë”ë§í•  ê³µê°„)ì„ GPUê°€ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ ëœë‹¤!*
>       *   Direct3Dì—ì„œ ë Œë” íƒ€ê²Ÿ ë·°ë¥¼ í†µí•´ ê·¸ë˜í”½ ì‘ì—…ì´ ê°€ëŠ¥í•´ì§
>   *   RTVëŠ” OM ìŠ¤í…Œì´ì§€ì—ì„œ ì‚¬ìš©ë¨
>       *   `OMSetRenderTargets`ë¡œ ì ìš©í•´ì•¼ ì‹¤ì§ˆì ì¸ ë Œë”ë§ì´ ì´ë£¨ì–´ì§

<br>

---

#### Depth Buffer

```c++
	// Depth Buffer Desc ì´ˆê¸°í™”
	ZeroMemory(&depthBufferDesc, sizeof(depthBufferDesc));

	// Depth Buffer Desc ì„¤ì •
	depthBufferDesc.Width = screenWidth;
	depthBufferDesc.Height = screenHeight;
	depthBufferDesc.MipLevels = 1;
	depthBufferDesc.ArraySize = 1;
	depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthBufferDesc.SampleDesc.Count = 1;
	depthBufferDesc.SampleDesc.Quality = 0;
	depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthBufferDesc.CPUAccessFlags = 0;
	depthBufferDesc.MiscFlags = 0;

	// ì´ˆê¸°í™”í•œ Descë¥¼ ì‚¬ìš©í•´ ê¹Šì´ ë²„í¼ ìƒì„±
    result = m_device->CreateTexture2D(&depthBufferDesc, NULL, &m_depthStencilBuffer);
    if (FAILED(result))
    {
        return false;
    }
```

**[Depth Buffer](https://learn.microsoft.com/ko-kr/windows/win32/direct3d9/depth-buffers) (ê¹Šì´ ë²„í¼, Z-ë²„í¼)**

*   í´ë¦¬ê³¤ì´ 3D í™˜ê²½ì—ì„œ ì œëŒ€ë¡œ ë Œë”ë§ë  ìˆ˜ ìˆë„ë¡ ê¹Šì´ ë²„í¼ ìƒì„±
*   ê¹Šì´ ë²„í¼ì— ìŠ¤í…ì‹¤ ë²„í¼ ì¶”ê°€
    *   ëª¨ì…˜ ë¸”ëŸ¬, Volumetric Shadows ê°™ì€ ê·¸ë˜í”½ íš¨ê³¼ êµ¬í˜„ ê°€ëŠ¥

<br>

*ì™œ ê¹Šì´ ë²„í¼ë¥¼ ìƒì„±í•˜ëŠ”ë° `CreateTexture2D` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í–ˆì„ê¹Œ?*

*   ê¹Šì´ ë²„í¼ëŠ” 2D í…ìŠ¤ì²˜ë¡œ ì´ë£¨ì–´ì§
    *   í´ë¦¬ê³¤ì´ ì •ë ¬ë˜ê³  ë˜ìŠ¤í„°í™”ëœ í›„, 2Dë¡œ ë§¤í•‘ë˜ì–´ í™”ë©´ì— ì¶œë ¥ë˜ê¸° ë•Œë¬¸!



<br>

---

#### Depth Stencil ì„¤ì •

**Depth Stencil Desc**

```c++
	// Depth Stencil Desc ì´ˆê¸°í™”
	ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));

	// Depth Stencil Desc ì„¤ì •
	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;

	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;

	// í”½ì…€ì´ Front-Facingì¸ ê²½ìš° ìŠ¤í…ì‹¤ ì—°ì‚°
	depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	// í”½ì…€ì´ Back-Facingì¸ ê²½ìš° ìŠ¤í…ì‹¤ ì—°ì‚°
	depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
```

ê¹Šì´ ìŠ¤í…ì‹¤ ì„¤ëª…(Depth Stencil Desc)ì„ ì„¤ì •í•œë‹¤.

D3Dê°€ ê° í”½ì…€ì— ëŒ€í•´ ì–´ë–¤ ìœ í˜•ì˜ ê¹Šì´ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í• ì§€ ì œì–´í•  ìˆ˜ ìˆë‹¤.

<br>

**Depth Stencil State**

```c++
    // ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœ ìƒì„± (ë””ë°”ì´ìŠ¤ ì‚¬ìš©)
    result = m_device->CreateDepthStencilState(&depthStencilDesc, &m_depthStencilState);
    if (FAILED(result))
    {
        return false;
    }

    // ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœ ì ìš© (ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©)
    m_deviceContext->OMSetDepthStencilState(m_depthStencilState, 1);
```

Descë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœ(Depth Stencil State) ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.

ìƒì„±ëœ ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœë¥¼ OM ìŠ¤í…Œì´ì§€ì— ì ìš©ì‹œí‚¬ ìˆ˜ ìˆë‹¤. ì´ë•Œ, ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•´ ì„¤ì •í•œë‹¤.

<br>

ğŸŒ± *ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœ*

`desc`ë¡œ ì €ì¥í•œ ì„¤ì •ê°’ì„ ìƒíƒœ ê°ì²´ë¡œ ë§Œë“¤ì–´ ê¹Šì´-ìŠ¤í…ì‹¤ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

<br>

ğŸŒ± *ì™œ ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©?*

ë Œë”ë§ ìƒíƒœë¥¼ ë³€ê²½í•˜ê±°ë‚˜, ì–´ë– í•œ ê·¸ë˜í”½ ëª…ë ¹ì„ ì‹¤í–‰í•˜ë ¤ë©´ ë””ë°”ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ê¸° ë•Œë¬¸!

*cf) ê¹Šì´ ìŠ¤í…ì‹¤ ìƒíƒœë¥¼ **ìƒì„±í•  ë•ŒëŠ” ë””ë°”ì´ìŠ¤ì˜ ë‚´ì¥ í•¨ìˆ˜**ë¥¼ í˜¸ì¶œí–ˆë‹¤.*

<br>

**Depth Stencil View**

```c++
	// Depth Stencil View ì´ˆê¸°í™”
	ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));

	// Depth Stencil View Desc ì„¤ì •
	depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Texture2D.MipSlice = 0;

	// Depth Stencil View Desc ìƒì„±
	result = m_device->CreateDepthStencilView(m_depthStencilBuffer, &depthStencilViewDesc, &m_depthStencilView);
```

ê¹Šì´ ìŠ¤í…ì‹¤ ë·° ì„¤ëª…(Depth Stencil View Desc)ë¥¼ ì„¤ì •í•œë‹¤. 

*D3DëŠ” Depth Stencil Bufferë¥¼ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—, ê¹Šì´ ìŠ¤í…ì‹¤ ë·°ë¥¼ ë§Œë“¤ì–´ D3Dê°€ ê¹Šì´ ë° ìŠ¤í…ì‹¤ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤!*

<br>

```c++
    // ë Œë” íƒ€ê²Ÿ ë·°ì™€ ê¹Šì´ ìŠ¤í…ì‹¤ ë²„í¼ë¥¼ Output Merger íŒŒì´í”„ë¼ì¸ì— ë°”ì¸ë”©
    m_deviceContext->OMSetRenderTargets(1, &m_renderTargetView, m_depthStencilView);
```

Depth Stencil Viewê°€ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ, `OMSetRenderTargets`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.

*   ë Œë” íƒ€ê²Ÿ ë·°ì™€ ê¹Šì´-ìŠ¤í…ì‹¤ ë²„í¼ë¥¼ ì¶œë ¥ ë Œë” íŒŒì´í”„ë¼ì¸ì— ë°”ì¸ë”©
*   íŒŒì´í”„ë¼ì¸ì´ ë Œë”ë§í•œ ê·¸ë˜í”½ì´ ì´ì „ì— ìƒì„±í•œ ë°± ë²„í¼ì— ê·¸ë ¤ì§
*   ê·¸ë˜í”½ì´ ë°± ë²„í¼ì— ê¸°ë¡ë˜ë©´ í”„ë¡ íŠ¸ ë²„í¼ë¡œ ìŠ¤ì™‘ => ì‚¬ìš©ì í™”ë©´ì— ê·¸ë˜í”½ ì¶œë ¥!

<br>

>   ğŸŒ±  íë¦„ ì´í•´í•´ë³´ì!
>
>   1.   `D3D11_DEPTH_STENCIL_DESC` êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•´ ê¹Šì´/ìŠ¤í…ì‹¤ í…ŒìŠ¤íŠ¸ ì„¤ì •
>
>        *   ê¹Šì´ ë¹„êµ í•¨ìˆ˜, ìŠ¤í…ì‹¤ ì—°ì‚° ë“± ì •ì˜
>
>   2.   ìƒì„±í•œ `D3D11DepthStencilState` ê°ì²´ë¥¼ OM stageì— ì„¤ì • -> í…ŒìŠ¤íŠ¸ ê·œì¹™ì´ í™œì„±í™”ë¨
>
>        *   ê°ì²´ ìƒì„±: `Device->CreateDepthStencilState()`
>        *   ê·œì¹™ ì ìš©:`DeviceContext->OMSetDepthStencilState()`
>
>   3.   `D3D11_DEPTH_STENCIL_VIEW_DESC`ë¥¼ ì„¤ì •í•´ ê¹Šì´/ìŠ¤í…ì‹¤ ë²„í¼ ë·° ì •ì˜
>
>        *   í…ìŠ¤ì²˜*(ê¹Šì´-ìŠ¤í…ì‹¤ ë²„í¼)*ì˜ íŠ¹ì • ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•¨
>
>   4.   `ID3D11DepthStencilView` ê°ì²´ë¥¼ OM stageì— ì—°ê²°í•´ í…ìŠ¤ì²˜ í™œìš©(ì•ì„œ ì ìš©í•œ í…ŒìŠ¤íŠ¸ ê·œì¹™ì´ ìˆ˜í–‰ë¨)
>
>        *   ê°ì²´ ìƒì„±: `device->CreateDepthStencilView()`
>
>        *   ê¹Šì´/ìŠ¤í…ì‹¤ ë·°, ë Œë” íƒ€ê²Ÿ ë·° ì ìš©: `deviceContext->OMSetRenderTargets()`

<br>

---

#### Rasterizer State

```c++
    // Raster Descì„ ì„¤ì •í•´ í´ë¦¬ê³¤ì´ ì–´ë–»ê²Œ ê·¸ë ¤ì§ˆì§€ ê²°ì •
    rasterDesc.AntialiasedLineEnable = false;
    rasterDesc.CullMode = D3D11_CULL_BACK;
    rasterDesc.DepthBias = 0;
    rasterDesc.DepthBiasClamp = 0.0f;
    rasterDesc.DepthClipEnable = true;
    rasterDesc.FillMode = D3D11_FILL_SOLID;
    rasterDesc.FrontCounterClockwise = false;
    rasterDesc.MultisampleEnable = false;
    rasterDesc.ScissorEnable = false;
    rasterDesc.SlopeScaledDepthBias = 0.0f;

    // descë¥¼ ê¸°ë°˜ìœ¼ë¡œ Rasterizer state ìƒì„±
    result = m_device->CreateRasterizerState(&rasterDesc, &m_rasterState);
    if (FAILED(result))
    {
        return false;
    }

    // Rasterizer ìƒíƒœ ì„¤ì •
    m_deviceContext->RSSetState(m_rasterState);
```

ë Œë” íƒ€ê²Ÿì´ ì„¤ì •ë˜ì—ˆìœ¼ë¯€ë¡œ, ì”¬ì„ ë”ìš± ì»¨íŠ¸ë¡¤ í•  ìˆ˜ ìˆëŠ” ëª‡ê°€ì§€ ì¶”ê°€ ê¸°ëŠ¥ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.

*   ë˜ìŠ¤í„°ë¼ì´ì € ìƒíƒœ(Rasterizer State) ìƒì„±
    *   í´ë¦¬ê³¤ì´ ë Œë”ë§ë˜ëŠ” ë°©ì‹ ì œì–´
    *   e.g. ì”¬ì„ ì™€ì´ì–´í”„ë ˆì„ ëª¨ë“œë¡œ ë Œë”ë§, DirectXê°€ í´ë¦¬ê³¤ì˜ ì•ë©´ê³¼ ë’·ë©´ì„ ëª¨ë‘ ê·¸ë¦¬ê¸°
    *   ê¸°ë³¸ì ìœ¼ë¡œ DirectXëŠ” ì¼ë°˜ì ì¸ ë˜ìŠ¤í„°ë¼ì´ì € ìƒíƒœê°€ ì„¤ì •ë˜ì–´ ìˆìŒ
        *   ë‹¨, ì§ì ‘ ë˜ìŠ¤í„°ë¼ì´ì € ìƒíƒœë¥¼ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ì œì–´í•  ìˆ˜ ì—†ë‹¤

<br>

---

#### Viewport ì„¤ì •

```c++
	// ë Œë”ë§ì„ ìœ„í•´ ë·°í¬íŠ¸ ì„¤ì •
	m_viewport.Width = (float)screenWidth;
	m_viewport.Height = (float)screenHeight;
	m_viewport.MinDepth = 0.0f;
	m_viewport.MaxDepth = 1.0f;
	m_viewport.TopLeftX = 0.0f;
	m_viewport.TopLeftY = 0.0f;

	// ë·°í¬íŠ¸ ìƒì„±
	m_deviceContext->RSSetViewports(1, &m_viewport);
```

ë·°í¬íŠ¸(Viewport) ì„¤ì •

*   Direct3Dê°€ í´ë¦½ ê³µê°„ ì¢Œí‘œë¥¼ ë Œë” íƒ€ê²Ÿ ê³µê°„ì— ë§¤í•‘ ê°€ëŠ¥
*   ë·°í¬íŠ¸ í¬ê¸°ë¥¼ ì°½ ì „ì²´ë¡œ ì„¤ì •

<br>





