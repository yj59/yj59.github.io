---
title: "[RasterTek/DirectX11] #2 프레임워크 및 창 만들기"

date: 2025-01-30 00:00:00 +0900
author: yejin

categories: [DirectX 11, Tutorials]
tags: [RasterTek, tuto]

math: true
---

> **📖 참고자료**
>
> * [RasterTek - DirectX 11 on Windows 10 Tutorials](https://rastertek.com/tutdx11win10.html)
>
> <br>
> 
> **🖥️ 개발환경**
> 
> *   Window 11
> *   Visual Studio 2022
>

<br>

DirectX11로 코딩을 시작하기 전에 간단한 프레임워크를 구축하는 것이 좋다.

해당 프레임워크는 기본적인 Windows 기능을 처리하고, DX11을 학습하기 위해 코드를 체계적이고 읽기 쉽게 확장할 수 있는 방법을 알려준다.

*rastertek 튜토리얼은 다양한 기능을 시도해 보는 것이므로, 프레임워크를 가볍게 유지하고 자체 렌더링 엔진을 만들지 않는다.*

<br>

# 프레임워크

프레임워크는 4가지 항목으로 시작한다.

![img](https://rastertek.com/pic6001.gif)

* `WinMain`: 애플리케이션의 진입점 처리
  * `SystemClass`: WinMain 함수 내에서 호출되는 애플리케이션 전체를 캡슐화
    * `InputClass`: 사용자 입력 처리
    * `ApplicationClass`: DirectX 그래픽 코드 처리

<br>

# WinMain

<br>

```c++
// Filename: main.cpp

#include "systemclass.h"


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pScmdline, int iCmdshow)
{
	SystemClass* System;
	bool result;
	
	
	// Create the system object.
	System = new SystemClass;

	// Initialize and run the system object.
	result = System->Initialize();
	if(result)
	{
		System->Run();
	}

	// Shutdown and release the system object.
	System->Shutdown();
	delete System;
	System = 0;

	return 0;
}
```

WinMain 함수에서 SystemClass를 생성한 후 초기화한다.

초기화에 문제가 없으면 SystemClass의 `Run`함수를 호출한다.

`Run` 함수는 자체적으로 반복문을 실행하고 애플리케이션 코드가 완료될 때까지 동작한다. `Run` 함수가 완료된 후 System object를 종료한다. 

전체 애플리케이션을 SystemClass 내부에 캡슐화해 간단하게 유지한다.



<br>

# SystemClass.h

<br>

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: systemclass.h
////////////////////////////////////////////////////////////////////////////////

#ifndef _SYSTEMCLASS_H_
#define _SYSTEMCLASS_H_
```

```c++
///////////////////////////////
// PRE-PROCESSING DIRECTIVES //
///////////////////////////////
#define WIN32_LEAN_AND_MEAN
```



`WIN32_LEAN_AND_MEAN`을 정의한다.

* 빌드 프로세스를 가속화하기 위해 사용하지 않는 일부 Win32 API 제외

  => Win32 헤더 파일의 크기 줄임



<br>

```c++
//////////////
// INCLUDES //
//////////////
#include <windows.h>

///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "inputclass.h"
#include "applicationclass.h"
```

`windows.h`를 포함해  윈도우의 생성자/소멸자 함수와 기타 win32 함수를 호출할 수 있게 한다. 프레임워크의 두 클래스를 include해 시스템 클래스에서 사용할 수 있도록 한다.

<br>

```c++
////////////////////////////////////////////////////////////////////////////////
// Class name: SystemClass
////////////////////////////////////////////////////////////////////////////////
class SystemClass
{
public:
	SystemClass();
	SystemClass(const SystemClass&);
	~SystemClass();

	bool Initialize();
	void Shutdown();
	void Run();

	LRESULT CALLBACK MessageHandler(HWND, UINT, WPARAM, LPARAM);

private:
	bool Frame();
	void InitializeWindows(int&, int&);
	void ShutdownWindows();

private:
	LPCWSTR m_applicationName;
	HINSTANCE m_hinstance;
	HWND m_hwnd;

	InputClass* m_Input;
	ApplicationClass* m_Application;
};
```

클래스 정의

* `WinMain`에서 호출된 `Initialize`, `Shotdown`, `Run` 함수
* 해당 함수에서 호출될 private 함수
* `MessageHandler`
  * 시스템이 실행되는 동안 애플리케이션에 전송될 Windows System message 처리
* `m_Input`, `m_Application`
  * 입력과 그래픽 렌더링을 처리할 두 객체에 대한 포인터

<br>

```c++
/////////////////////////
// FUNCTION PROTOTYPES //
/////////////////////////
static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

/////////////
// GLOBALS //
/////////////
static SystemClass* ApplicationHandle = 0;

#endif
```

`wndProc`, `ApplicationHandle`

=> 윈도우 시스템 메시지를 SystemClass의 MessageHandler 함수로 리디렉션할 수 있다.

<br>



# Systemclass.cpp

## 생성자

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: systemclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "systemclass.h"
```

```c++
SystemClass::SystemClass()
{
    m_Input = 0;
    m_Application = 0;
}
```

클래스 생성자에서 객체 포인터를 null로 초기화한다.

객체 초기화가 실패한 경우 `Shotdown` 함수가 해당 객체를 정리를 시도한다. 만약, 객체가 null이 아니라면 유효한 객체라고 판단하고 정리한다.

애플리케이션에서 모든 포인터와 변수를 null로 초기화하는 습관을 들이는 것이 좋다. 빌드 시 실패할 수도 있기 때문!



<br>

## 복사생성자&소멸자

```c++
SystemClass::SystemClass(const SystemClass& other)
{
}

SystemClass::~SystemClass()
{
}

```

복사 생성자와 소멸자가 공란일 경우 컴파일러가 임의로 만들 수 있다. 빈 복사 생성자와 소멸자를 만들어 놓는다.

<br>

## Initialize

```c++
bool SystemClass::Initialize()
{
    int screenWidth, screenHeight;
    bool result;

    // 화면 너비와 높이를 0으로 초기화한 후 InitializeWindows에 변수 전달
    screenWidth = 0;
    screenHeight = 0;

    // Initialize the windows api.
    InitializeWindows(screenWidth, screenHeight);

    // 입력 객체 생성 후 초기화
    // 사용자의 키보드 입력을 읽는데 사용됨
    m_Input = new InputClass;
    m_Input->Initialize();

    // 애플리케이션 객체 생성 후 초기화
    // 애플리케이션의 모든 그래픽을 렌더링하는 데 사용
    m_Application = new ApplicationClass;

    result = m_Application->Initialize(screenWidth, screenHeight, m_hwnd);
    if(!result)
    {
        return false;
    }

    return true;
}
```

`SystemClass::Initialize()`: 애플리케이션 설정을 수행

* `InitializeWindows`를 호출해 애플리케이션에서 사용할 창 생성
* 애플리케이션에서 사용자 입력을 처리
* 화면에 그래픽을 렌더링하는데 사용할 입력/애플리케이션 객체를 생성 후 초기화



<br>

## Shutdown 

```c++
void SystemClass::Shutdown()
{
	// Release the application class object.
	if(m_Application)
	{
		m_Application->Shutdown();
		delete m_Application;
		m_Application = 0;
	}

	// Release the input object.
	if(m_Input)
	{
		delete m_Input;
		m_Input = 0;
	}

	// Shutdown the window.
	ShutdownWindows();
	
	return;
}
```

`Shutdown`: 연관 동작 정리

* 애플리케이션 및 입력 객체와 관련된 모든 것을 종료 및 해제
* 윈도우를 종료하고 관련 핸들 정리

<br>

## Run

```c++
void SystemClass::Run()
{
	MSG msg;
	bool done, result;


	// Initialize the message structure.
	ZeroMemory(&msg, sizeof(MSG));
	
	// Loop until there is a quit message from the window or the user.
	done = false;
	while(!done)
	{
		// Handle the windows messages.
		if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		// If windows signals to end the application then exit out.
		if(msg.message == WM_QUIT)
		{
			done = true;
		}
		else
		{
			// Otherwise do the frame processing.
			result = Frame();
			if(!result)
			{
				done = true;
			}
		}

	}

	return;
}
```

`SystemClass::Run()`

* 애플리케이션이 종료하기 전까지 모든 동작 처리

* 애플리케이션 처리: 각 loop마다 호출되는 Frame 함수에서 수행

  => 애플리케이션 구현 시 염두에 두자!

  ```
  // pseudo code
  while not done
      check for windows system messages
      process system messages
      process application loop
      check if user wanted to quit during the frame processing
  While 종료되기 전
  	윈도우 시스템 메시지 확인
  	시스템 메시지 처리
  	애플리케이션 루프 처리
  	프레임 처리를 하는 동안 사용자가 종료를 원하는지 확인
  ```



<br>



## Frame

```c++
bool SystemClass::Frame()
{
	bool result;


	// Check if the user pressed escape and wants to exit the application.
	if(m_Input->IsKeyDown(VK_ESCAPE))
	{
		return false;
	}

	// Do the frame processing for the application class object.
	result = m_Application->Frame();
	if(!result)
	{
		return false;
	}

	return true;
}
```

`SystemClass::Frame()`

* 애플리케이션의 모든 동작을 처리하는 함수
* input object를 확인해 사용자가 `Esc`키를 눌러 종료하려는지 확인
* 종료를 원하지 않으면 ApplicationClass 객체를 호출해 프레임 처리 수행
  * 이 과정에서 해당 프레임의 그래픽 렌더링 수행
